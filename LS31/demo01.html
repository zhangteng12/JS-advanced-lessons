<!DOCTYPE html>
<html>
<head>
	<title></title><meta charset="utf-8">
	<script type="text/javascript">
				var obj = {
		    x:1,
		    y:2,
		    moveTo:function(x,y){
		        this.x = x;
		        this.y = y;
		    }
		}
		obj.moveTo = function(x,y){
		    console.log("方法被覆盖了");
		};
		obj.moveTo(0,0);

		//新增数据类型
		//ES6里就引入了Symbol，用它来产生一个独一无二的值。
		let s = Symbol();//不能用new
		typeof s;// "symbol"

		//Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。
		var s1 = Symbol('foo');
		var s2 = Symbol('bar');
		console.log(s1); // Symbol(foo)
		console.log(s2); // Symbol(bar)
		console.log(s1.toString()); // "Symbol(foo)"
		console.log(s2.toString()); // "Symbol(bar)"


		//相同参数的Symbol函数的返回值是不相等的。
		// 没有参数的情况
		var s1 = Symbol();
		var s2 = Symbol();
		s1 === s2 // false
		// 有参数的情况
		var s1 = Symbol("foo");
		var s2 = Symbol("foo");
		s1 === s2 // false

		//如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值
		const obj = {
		    toString() {
		        return 'abc';
		    }
		};
		const sym = Symbol(obj);
		sym // Symbol(abc)

		//Symbol值不能与其他类型的值进行运算，会报错。
		var sym = Symbol('My symbol');
		//"your symbol is " + sym;//报错
		//但是，Symbol值可以显式转为字符串。
		var sym = Symbol('My symbol');
		String(sym); // 'Symbol(My symbol)'
		sym.toString(); // 'Symbol(My symbol)'
	</script>
</head>
<body>

</body>
</html>